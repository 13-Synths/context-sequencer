COMMAND,OPERATOR,ALIAS(S),ARGUMENT(S),PARAMETERS,CATEGORY,DEFAULT,DESCRIPTION,MENU,GUI SHORTCUT,COMMENTS,USE,EXPLANATION,MESSAGE BOX 1,MESSAGE BOX 2,PRESET
:a,|,,$ | $ | $...,$ = symbol float or list,database,clear,define the whole database,no,no,This overwrites all previous database entries.,Use this to define the whole database at once.,Look in the text box popup to see what happens to these messages,:a first message | second message | third message | fourth message, :a 1 2 | 3 4 5 | 6, :e 5 :a -open :v 0 :pr 2
:a,,,$`1 $`2,$`1 = float = term‚ $’2 = symbol float or list,database,clear,define single field of database,no,no,Note that this command will not work as a creation argument. To define a specific term of the database using creation arguments‚ you must use bars ( | ).,Use this to define a single database field.,Look in the text box popup to see what happens to these messages,:a 1 a message, :a 3 another message, :a -open :v 0 :pr 2
:a,-open,,,,database,n/a,open text box to edit database,messages --> x-axis --> edit,no,The text edit tool must be saved (ctrl+s).,Use this tool to edit the database manually.,,:a -open,:a -clear,:a first message | second message | third message | fourth message :v 0 :pr 2
:a,-clear,,,,database,n/a,clear the database,messages --> x-axis --> clear,no,This can’t be undone!,Clear all messages from the database.,,:a -open,:a -clear,:a first message |  second message | third message | fourth message :v 0 :pr 2
:a,-scramble,,{$ $...},$ = float = database term,database,n/a,rearrange the specified fields in the database randomly,no,no,Specify the terms to scramble as arguments‚ or give no arguments to scramble all terms.The rearrangement is random and might turn out the same as before‚ especially with a small number of fields.,This is useful ie. for scrambling a melody.,':a -scramble 1 3 4' rearranges the 1st‚ 3rd and 4th field numbers. Ie. the 1st field might be moved to the 4th‚ the 4th to the 3rd‚ etc. If no arguments are specified‚ all fields are scrambled.,:a -scramble,:a -scramble 1 3 4,:a one | two | three | four :a -open :v 0 :pr 2
:a,+,+ - * or /,$’1 {$’2} {$’3},$’1 = value‚ $’2 = term‚ $’3 = field (floats),database,n/a,perform arithmetic on a database term,no,double (tripple...) click on symbol atom and drag up / down,If the term is unspecified‚ it will be interpreted as the current term. If the line number is unspecified‚ it will be interpreted as the current selected line (ie the one that flashes black in the toggle array). Note that only float terms are counted—symbols are left unaffected.,Use this to modify float terms in the database.,':a * 3 4 2' multiplies by 3 the 4th term of the 2nd field. ‘:a + 1’ adds 1 to the first term of whichever database field is selected. Use the arrow keys to change this selection.,:a + 1,:a * 3 4 2, :a 10 20 30 | 40 50 60 70 :a -open :v 0 :pr 2
:a,*.,,$,$ = float = ID number,database,n/a,read from another context’s database,no,no,This allows you to select another context’s database for plaback instead of this context’s own. Note that it will also clear the :a database.,This is useful because it allows you to store ‘master’ melodies which you can play back in different ways across several different contexts.,The number corresponds to another context’s ID number. Nothing much will happen in this example‚ since no other contexts are open.,:a *. 2,:a *. 3,:v 0
:b,,,,,,,,,,The :a and :b database commands have identical syntax. Everything listed under the :a help boxes applies also to :b.,,,needs some work,,:v 0
:c,,colour color,$,$ = float = PD color value,ID,11,set context colour,ID --> colour,no,The numbers argument is the same as regular PD colors. Positive numbers are presets (1-30 repeating) and negative numbers are RGB values.,Context colour schemes have no effect other than aesthetic.,,:c 15,:c -10300,:v 0
:d,,delay time cycle,$,$ = float = seconds,time,0,set context cycle duration in seconds,no,float atom (top left),Negative time values will reverse the context cycle. Note that the cycle time might also be effected by the coefficient (:k) and random time mode (:E),Set the cycle duration.,,:d 10,:d -2,:d 4 :x 1 2 4 :v 0 :pr 2
:d,m,M minute minutes,$,$ = float = minutes,time,n/a,set context cycle duration in minutes,no,no,Negative time values will reverse the context cycle. Note that the cycle time might also be effected by the coefficient (:k) and random time mode (:E),Use this operator for convenience. Note that it is not saved—it just converts the number to seconds.,,:d m 2,:d m 3,:v 0
:d,h,H hour hours,$,$ = float = seconds,time,n/a,set context cycle duration in hours,no,no,Negative time values will reverse the context cycle. Note that the cycle time might also be effected by the coefficient (:k) and random time mode (:E),Use this operator for convenience. Note that it is not saved—it just converts the number to seconds.,,:d h 1,:d h 0.5,:v 0
:d,+,+ - * or /,$,$ = float = value,time,n/a,perform arithmetic on cycle duration,no,no,,This can be used to alter timings in a defined way.,,:d - 1, :d * 2,:d 2 :v 0 :pr 2
:e,,,$,$ = float = database field,database,1,define the limit of the :a database,messages --> x-axis --> limit,no,The :a database contains as many fields as there are toggles on the x-axis‚ but not all of them are necessarily read. This setting determines how far along the :a database the x-axis toggles will read. A blank database field will give a bang.,':e 1' (default) means that only the first field is ever read. This means that the context will always send the same message‚ regardless of which toggle fires. If the x-axis contains 9 toggles‚ ':e 8' means that every toggle will deliver its own unique message (the 9th toggle belong to the y-‚ not the x-axis). This is useful for playing melodies or sending complex messages. In the same context‚ ':e 4' will read the first four fields and then repeat the last one for toggles 5-8.,Look at the context symbol atom to see which database entry is accessed. Changing the :e setting will change how many fields are read. (Note that this example starts with the default :e 1).,:e 4,:e 2,:a one | two | three | four :x 1 2 3 4 5 :i 5 1.5 :d 2 :s :v 0 :pr 2
:f,,,$,$ = float = database field,database,1,define the limit of the :b database,messages --> y-axis --> limit,no,This works the same as the ':e' command.,,** probmlem here: the burst message isn’t properly setting the message atom.,:f 4,:f 1,:b one | two | three | four :y 1 2 3 4 :i 5 1.5 :d 2 :L linear :s :v 0 :pr 2
:g,,gui GUI,$,$ = float = state (-1‚ 0‚ 1),general,0,set context GUI,other --> more --> gui off,right click + properties,:g 1 calls the properties menu‚ while :g 0 calls the normal GUI. :g -1 turns the GUI off and deletes/prevents from loading a significant portion of the patch which runs the GUI. The context continues to function as normal but consumes fewer CPU resources‚ a bit like a power saving mode.,Use :g -1 in cases where a context is embedded or when you will have no need to edit its settings manually. Note that this cannot be undone by sending a :g 0 message. If you want to turn the GUI back on‚ you will have to recreate the context without the :g -1 creation argument. (Note further that creation arguments are not live updated inside the object‚ so if you want to return to the GUI in a context whose state has changed‚ you have to save‚ reload‚ and then delete the :g -1 argument.),:g (no argument) will switch between :g 0 and :g 1. :g-1 will turn the GUI off (you’ll have to close and re-open this help patch if you want it back!),:g,:g -1,:v 0 :pr 2
:h,,quantity,$,$ = float = burst toggle number,burst,0,define the quantity of  burst toggles,burst --> quantity --> define,no,:h 0 (default) means ‘all toggles’. :h is overwritten by the random and progression settings (:p and :l) and by the 'which' setting (:o),Use this to determine how many burst toggles will fire at the end of the next context cycle. Note that only selected toggles can fire‚ so ':h5' will set 5 toggles to be fired only if there are five or more open.,Count how many toggles fire each cycle to see the effect of the :h setting,:h 3,:h 1,:i 5 1 :y = 1 2 3 4 :d 1 :s :v 0 :pr 2
:i,,,$ $...,$ = values‚ count = no. of x-axis toggles,toggles,clear,define all of the toggle-floats on the x-axis,no,no,0 is interpreted as blank. This will only work when the arguments are euqal to‚ or one less than‚ the number of toggles on the x-axis. The 'one less than' rule helps to avoid confusion regardling the bottom-right toggle. Note that a decimal place indicates an ID number‚ ie. ‘4.5’ becomes ‘c4’.,Use this to define the whole float array at once.,Note that negative toggle-floats have a special function—see the FAQ entry.,:i 1 2 3 4 5,:i -2 0 -5 0 0,:x 1 2 3 4 5 :v 0 :pr 2
:i,,,$’1 $’2 $’1 $’2...,$’1 = toggle position‚ $’2 = value (floats),toggles,n/a,define toggle-floats individually on the x-axis.,no,double click on a toggle and scroll up or down,A single pair is the most common use‚ but any number of pairs can be specified.  Note that a decimal place indicates an ID number‚ ie. ‘4.5’ becomes ‘c4’.,Use this to define toggle floats individually.,The second example changes the 1st toggle to -4‚ the 2nd toggle to -5‚ and the 3rd toggle to -6. Note that negative toggle-floats have a special function—see the FAQ entry.,:i 2 3,:i 1 -4 2 -5 3 -6,:x 1 2 3 4 5 :i 1 1 1 1 1 :v 0 :pr 2
:i,+ or -,,$’1 $’2,$’1 = value‚ $’2 = toggle number (floats),toggles,n/a,perform arithmetic on toggle-floats individually,no,no,,,‘:i – 4 2’ subtracts 4 from the second toggle-float. Note that negative toggle-floats have a special function and aren’t really negative‚ hece the addition. See the FAQ entry.,:i + 2 3,:i - 4 2,:x 1 2 3 4 5 :i 1 1 1 1 1 :v 0 :pr 2
:i,s,swap,$ $,$ = float = toggle position,toggles,n/a,switch the values of two toggle-floats,no,double click on a toggle and scroll left or right to switch adjascent floats,,Use this to alter a context network (or a melody) in a defined way.,':i s 2 5' switches the float values of the 2nd and 5th toggles.,:i s 1 2,:i s 2 5,:x 1 2 3 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:i,> or <,,$,$ = float = value,toggles,n/a,shift the whole float-array f places to the left / right,no,no,,Use this to offset a pattern of floats.,':i > 1' shifts the toggle array 1 place to the right‚ so ie. '1 2 3 4 5' becomes '5 1 2 3 4'. The middle toggle is off‚ so appears blank.,:i > 1,:i < 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:i,>> or <<,,$,$ = float = value,toggles,n/a,shift the float-array together with the toggle array f places to the left / right,no,no,This is identical to the ':x >> f' command.,This is more useful than >‚ which moves the float array independently of the toggle array. The difference is hard to describe but visually intuitive.,':i << 2' shifts the float and selection arrays 2 places to the left.,:i >> 1,:i << 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:i,x,,$ $ ...,same as :i,toggles,n/a,define toggle floats at the same time as the toggle array,no,double click on a toggle and scroll left or right to switch adjascent floats,This command sets the toggle array (on-off) at the same time as the toggle float values.,This is useful for quickly defining a pattern or array‚ as you don’t have to consider :i values separately from the :x.,compare this to using only the :i command,:i x 2 3,:i x 1 0 3 4,:v 0
:i,-l,,{$} ...,$ = float = value‚ followed by any other :i arguments,toggles,n/a,excepts the last toggle(s) from a :i command,no,no,The -l operator is used in conjunction with other :i commands. It protects the last toggle‚ so that it is not changed by the command. The -l command can take an opotional float argument‚ specifying the number of toggles from the back which should be protected. If no argument is specified‚ the default number is 1.,Use this if you want to rotate or clear toggles while leaving the last one intact (ie. if it is being used for a loop).,Watch the last toggle in this example. It is unaffected by the commands because of the -l operator.,:i -l >>,:i -l 3 clear,:v 0 :i 1 2 3 4 5 :x 1 2 3 5
:i,clear,,,,toggles,n/a,clear toggle float array,no,no,This sets all toggle floats back to 0.,,,:i 1 2 3 4 5,:i clear,:i x 1 3 4 5 :v 0 :pr 2
:i,scramble,,{$ $...},$ = float = toggle float number,toggles,n/a,rearrange the specified toggle floats randomly,no,no,Specify the toggles to scramble as arguments‚ or give no arguments to scramble all toggles. The rearrangement is random and might turn out the same as before‚ especially with a small number of fields.,This is useful ie. for scrambling a melody.,':i scramble 1 3 5’ rearranges the 1st‚ 3rd and 5th terms. ‘:i scramble’ rearranges all terms.,:i scramble 1 3 5,:i scramble,:i x 1 2 3 4 5 :v 0 :pr 2
:j,,,,,,,,,,The :i and :j array commands have identical syntax. Everything listed under the :i help boxes applies also to :j.,,,,,:v 0 :pr 2
:k,,,$,$ = float = value (not zero),time,1,define a multiplier or divider for the delay time,timing --> calculation --> factor,no,This works in conjunction with the coefficient mode‚ :K.,Use this to set a unit other than seconds for the time atom.,,:k 3,:k 1,:x 5 :i 5 1.5 :d 1 :K 1 :s :v 0 :pr 2
:k,,,$ $...,$ = float = time (seconds),time,n/a,store a custom map for map calculation,timing --> calculation --> map list,no,This stores a custom list of cycle time values to be selected by the :d value when :K 4 is on. When :d is 0‚ the first value on the list will be selected. When :d is 2‚ the second value will be selected‚ etc. If the :d value is higher than the number of items on the list then the cycle time value rolls back to :d itself.,Use this if you want custom time mappings that cannot be calcuated.,Load the :k list and turn :K 4 on and you will see that the cycle times correspond to the numbers in the list. Notice that when :d is 5 the cycle time is 5‚ since there are only 4 numbers on the list.,:K 4,:k 4 5 8 9,:v 0 :E 1 :x 5 :i 5 1.5 :d 5 :s :pr 2
:l,,,$,$ = float = percentage,burst,0,randomize the quantity of burst toggles,burst --> quantity --> random,no,This setting works as a percentage. 0 means that the burst quantity (:h) is definitive and 100 means that it is totally random. Number in between describe varying degrees on uncertainty‚ so that the burst quantity will deviate from :h with :l likelihood‚ according to Gaussian distribution. 101 gives even distribution through an ‘urn’ generator. This means that all available numbers will be used once before the urn is reset‚ like pulling numbers out of a bag. The urn can be reset manually using the ‘bump l’ command.,Use this setting to add uncertainty in a context network.,,:l 100,:l 10,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 2 :s :v 0 :pr 2
:l,-open,,,,burst,n/a,edit random distribution array,burst --> quantity --> edit random,no,This command opens the array which defines the probabilities for the :l setting. Normally you will see a Bell curve here (if :l is greater that 0 and less than 100)‚ but you can draw in a curve to define a new range of probabilities. Unfortunately‚ any changes you make here are unsavable.,Use this to define custom probabilities for the burst quantity.,Open the array and draw in your own curve. You will see the changes reflected in the number of burst toggles that fire.,:l -open,:l 20,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 2 :s :v 0 :pr 2 :l 30
:m,,advance,$,$ = float = state (0‚ 1),burst,1,determine whether the burst set auto-advances after every cycle,burst --> auto advance,no,This command turns off the auto-advance for burst selection. When it is on‚ a new set of burst toggles is calculated after every context cycles. When off‚ a new set on toggles is not calculated‚ unless a ‘bump’ command is received.,Use this to to hold the current burst selection.,While :m 0 is set‚ the toggle selection won’t advance unless the context receives a ‘bump’ message. When :m 1 is set‚ toggle selection advances each burst cycle.,bump,:m,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 1 :m 0 :P 1 :s :v 0 :pr 2
:n,,tag name,$’1 $’2...,$ = symbol = tag,ID,clear,define ID tags,ID --> tags,no,Context receives all messages sent to 'tag' and sends messages sent to 'tag-'. So you could send a message to the context from the example using [send drum] and receive messages from it using [receive cymbal-]. Note that assigning and removing tags can cause audio glitches.,Use tags to define groups of contexts‚ ie. 'percussion' for all the 'drums' and 'cymbals'. One context can have any number of tags‚ and a tag can be shared between any number of contexts.,':n drum cymbal' assigns the tags 'drum' and 'cymbal'.,:n tag-1 tag-2,:n drums cymbal,:X 10 :v 0 :pr 2
:n,+,tag name,$’1 $’2...,$ = symbol = tag,ID,n/a,add or remove ID tags,ID --> tags,no,The + operator indicates that the given symbols should be added or subtracted to the tag list. If a new symbol matches an existing tag it will be subtracted‚ and if not added. Causes audio glitches.,Note that the + operator is not neccessary when editing from within the menu‚ where typed symbols are automatically added or removed.,,:n + jam,:n + cheese,:X 10 :n jam bread :v 0 :pr 2
:n,=,tag name,$’1 $’2...,$ = symbol = tag,ID,n/a,define ID tags,ID --> tags,no,The = operator defines an exact list of tags‚ just as the :n command with no operator. Causes audio glitches.,Note that this operator is only needed inside the menu‚ where symbols are added or removed by default.,No example given (use the menu).,,,:v 0
:n,-clear,tag name,,,ID,n/a,clear ID tags,ID --> clear tags,no,This causes audio glitches.,Use this to clear all tags.,,:n -clear,,:X 10 :n ‘ unwanted tags ‘ :v 0 :pr 2
:o,,which,$ $...,$ = float = toggle number,burst,1,define an exact burst set,burst --> selection --> define,select burst toggles while idle (not savable),This will force the given toggles despite other burst settings‚ and defines a new mid point for random and progression deviations.,Use this to force a given path in the context network‚ or put it as a creation argument to specify the first outcome.,Choose exactly which toggles will fire at the end of the next burst. Note that in this example‚ auto-advance is off (:m 0) to prevent the burst selection from updating.,:o 2,:o 1 3 5,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :m 0 :h 1 :d 1 :s :v 0 :pr 2
:p,,,$,$ = float = value,burst,0,define an arithmetic progression for the burst quantity,burst --> quantity --> progression,no,Note that if 10 toggles are selected‚ ':l 9'  is equivalent to a decreasing progression.,Use this to make a context network increase in activity.,Look at how many toggles are firing each cycle.,:p 1,:p 2,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :h 1 :d 1 :s :v 0 :pr 2
:q,,,$,$ = float = state (0‚ 1),time,1,set a minimum for random cycle times,timing --> random options --> minimum,no,This setting only has effect in conjunction with :E 1,By default‚ a random cycle time might return as zero. Use this setting if you want to raise the bar of the minimum value of random cycle timing.,Here‚ random timing is on (:E 1) and the maximum time is 4 (:d 4). The :q value is 0 by default‚ meaning that zeros are allowed in the random timing. When the cycle time turns zero‚ the context stops. This is because the context safety mechanism rejects any instant feedback (this can be turned off with :z 0). When :q is set to 1 or 2‚ this value becomes the new minimum for random cycle times.,:q 1,:q 2,:x 5 :i 5 1.5 :d 4 :E 1 :s :v 0 :pr 2
:r,,record,$’1 $’2 {$’3},$’1 = state (0‚ 1)‚ $’2 = symbol‚ $’3 = value (ms),operation,n/a,record data to the context pattern toggles and pattern database,no,no,With this command you can record data to the context pattern toggles and pattern database. The cycle time is the duration of the recording and the pattern size (usually the number of toggles on the x-axis) is the ‘resolution’. The $’1 argument is either 0 or 1 (‘now’). 1 means that the recording will start immediately and 0 means that it starts with the next received input. $’2 specifies the channel through which the recording will be taken. ‘inlets’ specifies the context’s inlets. Any other symbol is interpreted as a receive channel‚ so ‘record 1 drums’ would receive messages send to [s drums]. Context tags and the ‘context’ symbol are particularly useful here. $’3 (optional) brings the recording threshold back‚ so that input received in the last x mili-seconds of the range of a particular toggle will fall into the next.,Use this for live input patterns for context‚ or to have context sample itself.,Press record and then click the ‘bang’ button in a rhythmic way. You will see the pattern appear along the x-axis as you create it. Then try with the message ‘:r 0 inlets 800’. This is a high threshold for illustration purposes.,test,:r 1 inlets,:X 9 :d 4 :v 0 :a -open :pr 2
:s,,start,,,operation,n/a,start a context cycle,no,double click on canvas area,Cable and float connections are equivalent to the :s message.,Use this to start a context automatically.,,:s,start,:x 1 2 :d 1 :v 0 :pr 2
:s,,start,$,$ = float or symbol,operation,n/a,start a context cycle,no,no,Arguments do not affect a start message‚ but can be useful in conjunction with the exception list.,If a start message argument agrees with an exception list entry‚ it will be filtered out. You can use this as a new method of controlling the flow of messages.,Here‚ ‘start’ will be allowed but ‘start 2’ will not‚ because of the exception list.,start,start 2,:v 0 :d 1 :ex ' start 2 ' :I 1 :pr 2
:s,p,start,$,$ = float = toggle number,operation,n/a,start a context at a particular toggle point along the pattern axis,no,no,The float corresponds to the position of the toggles along the pattern axis.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Look at the position on the x-axis floats to see where it starts.,:s p 3,:s p 8,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,p,start,$ $,$ = float = toggle number,operation,n/a,start a context‚ and schedule its stopping‚ at a particular point,no,no,Floats correspond to positions of the toggles along the pattern axis. If the first float is bigger than the first then the context will play in reverse.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Look at the position on the x-axis floats to see where it starts and stops,:s p 3 6,:s p 15 10,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,s,start,$,$ = float = time index,operation,n/a,start a context at a particular time index along the timeline,no,no,The float corresponds to a particular time index along the timeline. If the context cycle time is altered‚ the time index will change correspondingly.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Change the time cyce (top left atom) to understand s operator.,:s s 1,:s s 2.4,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,s,start,$ $,$ = float = time index,operation,n/a,start a context‚ and schedule its stopping‚ at a particular time index,no,no,The floats correspond to particular time index along the timeline. If the context cycle time is altered‚ the time indeces will change correspondingly. If the first float is bigger than the first then the context will play in reverse.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,Change the time cyce (top left atom) to understand s operator.,:s s 1 3,:s s 3.4 1.8,:: long :d 4 :x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :v 0 :pr 2
:s,m,start,$,$ = float = marker number,operation,n/a,start a context at a particular marker,no,no,The float corresponds to the ID number of a [marker] object embedded in the Context timeline.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,No example given—see ‘embedding.pd’ (warning: this patch takes several minutes to load).,,,:v 0
:s ,m,start,$ $,$ = float = marker number,operation,n/a,start a context‚ and schedule its stopping‚ at a particular marker,no,no,The floats correspond to the ID numbers of [marker] objects embedded in the Context timeline.,Use this to start a context at a point other than the beginning‚ or to chop-up a sample.,No example given—see ‘embedding.pd’ (warning: this patch takes several minutes to load).,,,:v 0
:t,,,$,$ = float = state (0‚ 1),general,0,determine how context responds when its cycle is interrupted,other --> more --> interrupt,no,When this is on‚ context will restart if it is interrputed in the middle of its cycle. When off‚ context will not allow interruption until it has reached the end of its cycle.,Use this to freeze a particular context once it has been started.,Start the context rapidly several times. Then turn click :t 0 and do it again. Notice the difference in behaviour.,start,:t 0,:d 2 :v 0 :pr 2
:u,,bank,$,$ = float = bank term,bank,1,retrieve a context state from the storage bank,no,double press and hold shift and click on y-axis toggles,Each Context has a storage bank which is capable of storing multiple Context states. This command jumpts to a new term from the bank‚ which loads a new pre-set (unless the term is blank). Any further changes to the context will be saved in that slot (see bank saving).,The GUI selector allocates as many terms in the bank as there are toggles on the y-axis‚ but you can create more by using this command and editing the bank list (:A open). Use the “preset” abstraction to define a different list of settings for the bank to store (default :a :b :x :y :d :i and :j).,Here the states saved in the bank are toggles and cycle time‚ but they could be anything.,:u 1,:u 2,:d 1 :x = 1 :y = 1 :ba ' :x = 1 :y = 1 :d 1 || :x = 1 2 3 :y = 1 2 3 :d 2 ' :v 0 :pr 2
:u,,bank,,,bank,n/a,cycle through terms of storage bank,no,no,Sending a :u command without any arguments jumps to the next bank term. Note that this includes bank terms that are empty. If you want to skip empty terms‚ you can delete them by editing the bank list (:A -open) and deleting empty lines (ie. semi-colons).,This is useful for creating a Cotnext which changes state each time it finishes a cycle.,Here the y-axis toggle sends a message ‘:u’ every time it is hit‚ signalling the bank term to advance. The result is that the x-axis toggles change after every cycle. Pressing ‘:u’ manually advances the state‚ while ‘:u 0’ resets it.,:u,:u 0,:d 2 :x 1 5 :ba ' :x = 1 5 || :x = 1 2 5 || :x = 2 3 5 ' :i 5 1.5 start :y = 1 :b ' . :u ' :v 0 :pr 2 :A 0
:v,,saving,$,$ = float = state (0‚ 1),saving,1,determine whether new settings will be saved,other --> state --> auto save,no,Warning: This might crash in conjunction with content auto-saving.,Turn this off if you don’t want new context states to be saved to the file‚ ie. if the context gets dynamically changed during playback but you want its original state to remain the same.,No example is given because the effect isn’t very visible. However‚ it should be pointed out that all the context used in this example has :v 0‚ to prevent any changes being saved.,,,:v 0 :pr 2
:w,,,$,$ = float = state (0‚ 1),burst,0,determines whether random burst quantities can wrap,burst --> quantity --> wrap,no,,When there is a small amount of random deviation to the number of burst toggles (ie. :l 10)‚ the number will follow a ‘drunken walk’ pattern. This setting determines whether it hits a ‘wall’ at the end or whether it wraps back around‚ ie. If the number of toggles can randomly go from 1 to the highest number in one step or not.,,:w 1,:w 0,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :l 10 :d 1 :s :v 0 :pr 2
:x,,,$ $...,$ = float = toggle number,toggles,n/a,turn toggle(s) on the x-axis on or off,no,click on toggles,This is equivalent to sending a ‘bank’ message to each toggle.,This command turns toggles on if they are off and off if they are on.,,:x 1 2 3,:x 2 3 4,:v 0 :pr 2
:x,+,,$ $...,$ = float = toggle number,toggles,n/a,turn toggle(s) on the x-axis on,no,no,This is equivalent to sending a 1 to each toggle.,This command turns toggles on if they are off. If a toggle was already off‚ no action is taken.,Note that these commands have no effect if the toggle(s) are already on.,:x + 1 2 3,:x + 2 3 4,:x 1 :v 0 :pr 2
:x,-,,$ $...,$ = float = toggle number,toggles,n/a,turn toggle(s) on the x-axis off,no,no,This is equivalent to sending a 0 to each toggle.,This command turns toggles off if they are on. If a toggle was already on‚ no action is taken.,Note that these commands have no effect if the toggle(s) are already on.,:x - 1 2 3,:x - 2 3 4,:x 1 3 4 5 :v 0 :pr 2
:x,=,:x def,$ $...,$ = float = toggle number,toggles,=,define a set of x-axis toggles,no,no,Sending a blank ‘:x =’ clears the toggle array.,This command defines exactly a set of toggles to turn on. All other toggles are turned off.,,:x = 1 2,:x = 2 3 4 5,:x 2 3 4 :v 0 :pr 2
:x,> or <,,$,$ = float = value,toggles,n/a,shift the whole toggle array f places to the left / right,no,no,,Use this to offset a pattern.,Notice how the toggle pattern moves without the floats.,:x > 1,:x < 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:x,>> or <<,,$,$ = float = value,toggles,n/a,shift the float array toggether with the toggle array,no,no,This is identical to the ':i >> f' command.,This is more useful than >‚ which moves the toggle array independently of the float array. The difference is hard to describe but visually intuitive.,Notice how the toggle pattern and the floats move together.,:x >> 1,:x << 2,:x 1 2 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:x,-l,,{$} ...,$ = float = value‚ followed by any other :i arguments,toggles,n/a,excepts the last toggle(s) from a :x command,no,no,The -l operator is used in conjunction with other :x commands. It protects the last toggle‚ so that it is not changed by the command. The -l command can take an opotional float argument‚ specifying the number of toggles from the back which should be protected. If no argument is specified‚ the default number is 1.,Use this if you want to rotate or clear toggles while leaving the last one intact (ie. if it is being used for a loop).,Watch the last toggle in this example. It is unaffected by the commands because of the -l operator. ‘:x 0 clears the array.,:x -l <,:x -l 2 0,:v 0 :x 1 2 4 5
:x,clear,0,,,toggles,n/a,clear the toggle array,no,no,This rests all toggles,,,:x 1 2 3 4 5,:x clear,:x 1 2 3 4 5 :v 0 :pr 2
:y,,,,,,n/a,,,,The :x and :y commands have identical syntax. Everything listed under the :x help boxes applies also to :y.,,,,,:v 0
:z,,safety,$,$ = float = state (0‚ 1),general,1,turn off two safety features which help to prevent stack overflows,timing --> more --> safety,no,Context networks often form feedback loops‚ and this can lead to stack overflows‚ especially when the accumulated cycle time is 0. :z turns on (by default) two safety features which prevent this. 1: The minimum cycle time of a context is clipped to 10ms‚ not zero. This means that loops of 0ms cannot occur. 2: When a context is started‚ its input is blocked for the same period of time (10ms). This likewise prevents context from entering into infinite loops‚ ie. If the first toggle of the pattern array references itself.,You might want to turn the safety off if you decide you definitely want a context of 0ms. But you do so at your own risk! Be prepared for stack overflows.,Do you really want to see a stack overflow? Then turn safety off (:z 0) and press start. A feedback loop is created because context restarts itself after 0ms.,:z 0,start,:x 1 :i 1 1 :d 1 :pr 2
:A,,,$,$ = float = state (0‚ 1),bank,0,determines whether the context state is auto-saved to the bank,other --> preset bank --> auto save,no,When this is on‚ every change that is tracked by the bank will trigger the bank to save.,If you turn this off‚ the bank will recall a context state but not update it in the bank. This can be useful if the context has been updated and you want to reload its origin point.,This context modifies its pattern at the end of every cycle (the :b database contains the message ‘:x (?8 + 1)’ ). With bank auto-saving turned off (:A 0)‚ calling the bank (:u 1) will recall the original pattern‚ since the pattern is not updating. With auto-saving on (:A 1)‚ calling the bank will have no effect.,:A,:u 1,:X 9 :x 1 3 5 7 9 :i 9 1.5 :d 2 :v 0 :y 1 :s :b ' . :x (?8 + 1) ' :A 0 :ba ' :x = 1 3 5 7 9 ' :pr 2
:A,-save,,,,bank,n/a,save the current context state to the bank,other --> preset bank -->save now,no,,Use this to save a context state if you have turned auto-saving off (:A 0).,This context modifies its pattern at the end of every cycle. Since bank auto-saving is of (:A 0)‚ you can recall the original patten by pressing :u 1 and set a new ‘origin’ by pressing :A -save.,:A -save,:u 1,:X 9 :x 1 3 5 7 9 :i 9 1.5 :d 2 :v 0 :y 1 :s :b ' . :x (?8 + 1) ' :A 0 :ba ' :x = 1 3 5 7 9 ' :pr 2
:A,-open,,,,bank,n/a,open a text dialogue to manually edit bank,other --> preset bank --> edit,no,The text edit tool must be saved (ctrl+s).,Use this to manually edit the bank list.,,:A -open,:A -clear,:ba ' :x = 1 3 5 || :x 2 4 ' :v 0 :pr 2
:A,-clear,,,,bank,n/a,clear the bank,other --> preset bank --> clear,no,This can’t be undone!,Use this to clear the bank list.,,:A -open,:A -clear,:ba ' :x = 1 3 5 || :x 2 4 ' :v 0 :pr 2
:B,,,$,$ = float = value,time,0.5,set the units for positional timing mode,timing --> position options --> resolution,no,This setting only effects positional timing (:E 2). It determines the resolution at which the cycle time will change as you drag it across the screen.,Set the interval to whatever (positive) value you want. Ie. 0.5 will allow for half second intervals‚ 2 for 2 second intervals‚ etc.,Enter edit mode (Ctrl+E) and drag this context around the canvas‚ watching what happens to the cycle time (top left atom). Then change the positional resolution (:B) and try again. (Note that the origin point of this canvas is the top left corner.),:B 0.1,:B 2,:E 2 :v 0 :X 9 :Z 15 :pr 2
:C,,,$,$ = float = value,time,20,determine how fast the timing alters in positional timing,timing --> position options --> scale,no,This setting only effects positional timing (:E 2). It determines the how fast the cycle time will change as you drag it across the screen.,Use high numbers for a lot of change and low numbers for less change. Note that the 0 point is ether the origin of the canvas or the context with n-1 ID number (if this one also has :E 2 on).,Enter edit mode (Ctrl+E) and drag this context around the canvas‚ watching what happens to the cycle time (top left atom). Then change the positional resolution (:B) and try again. (Note that the origin point of this canvas is the top left corner.),:C 5,:C 60,:E 2 :v 0 :X 9 :Z 15 :pr 2
:D,,,$,$ = float = value (positive),time,1,set the units for random timing mode,timing --> random options --> resolution,no,This setting only effects random timing (:E 1). It determines the allowed intervals at which random timings are allowed.,Set the interval to whatever (positive) value you want. Ie. 0.5 will allow for half second intervals‚ 2 for 2 second intervals‚ etc. Use long decimals for fractions ie. 0.3333333 for 1/3.,Select the different units and see what it does to the time intervals (top left atom). Note that :q (minimum) is set to 1 here‚ otherwise the series would start at 0.,:D .3333333,:D 2,:E 1 :v 0 :d 4 :x 5 :i 5 1.5 :s :q 1 :pr 2
:E,,random position off,$,$ = float (0‚ 1‚ 2) or symbol (see alias),time,0,determine how context cycle times are set,timing --> delay mode,no,0 is normal mode: timings are set by the :d value or the atom in the top left corner of the GUI. 1 is random mode: timings are random‚ with :d being the maxumim (see the :D‚ :q and :Q settings). 2 is positional mode: the time is set by the context’s position on the canvas‚ with :d having no effect (see the :B and :C settings).,Use this to switch between different timing modes.,In random mode (:E 1)‚ start (double click) on context to see how the time changes. In positonal mode (:E 2)‚ move the context around the screen to see the time change. (You will have to be in PD’s edit mode to do this—press Ctrl+e).,:E 1,:E 2,:d 4 :pr 2
:F,,,$,$ = float = value,general,0,set x-axis zoom,no,shift + double click and drag over the right-hand margin,The units are measured in pixles past the default size (which is 12 pixels per togle). It doesn’t update very fast‚ so it is best not to send a continuous stream of :F values.,This is useful to improve the readability when toggle floats are on. It is also used when context is embedded.,,:F 20,:F -10,:x 1 2 3 4 5 :i 1 2 3 4 5 :v 0 :pr 2
:G,,,$,$ = float = value,general,1,set y-axis zoom,no,shift + double click and drag over the bottom margin,The units are measured in pixles past the default size (which is 12 pixels per togle). It doesn’t update very fast‚ so it is best not to send a continuous stream of :G values.,This is useful to improve the readability when toggle floats are on. It is also used when context is embedded.,,:G 20,:G -10,:y 1 2 3 4 :i 1 2 3 4 :v 0 :pr 2
:H,,,$,$ = float > 1,saving,0,identify where the overlay instructions start within the saving list,no,no,:H must come at the beginning of the saving list‚ if at all., :H takes care of itself and is best not tampered with.,No example given.,,,:v 0
:I,,,$,$ = float = state (0‚ 1),input,0,turn the exception list on or off,other --> exceptions --> on-off,no,The exception list is a user defined list of (any) terms (:ex). If it is turned on (:I 1)‚ all context input is comared against each item on the list. If it matches‚ the input will be rejected. If not‚ it will continue as normal. Note that it is best to keep this function off if you are not using it‚ since it slows things down a bit.,Exceptions are used to filter incoming commands. You can protect a particular setting from being altered by adding it as an exception‚ or you can prevent context from being started under certain conditions.,Here‚ the exception list contains the text ‘start 2’. Turn exceptions on (:I) and the message ‘start 2’ will be rejected (‘start 1’ would still pass normally). Turning the exception list off (:I) means that all messages will be accepted as normal.,:I,start 2,:v 0 :d 1 :ex ' start 2 ' :pr 2
:I,-save,,,,input,n/a,save exception list,other --> exceptions --> save,no,Unfortunately‚ it is necessary to send this command after you have edited the exception list‚ else it won’t load.,,,:I -save,:I -open,:v 0 :d 1 :ex ' start 2 ' :pr 2
:I,-open,,,,input,n/a,open a text dialogue to manually edit the exception list,other --> exceptions --> edit,no,,Use this to manually edit the exception list (separating entries with semi-colons). Unfortunately‚ you have to send the ‘save’ command or hit ‘save’ in the menu‚ or else it won’t load.,,:I -save,:I -open,:v 0 :d 1 :ex ' start 2 ' :pr 2
:I,-clear,,,,input,n/a,clear the exception list,other --> exceptions --> clear,no,This can’t be undone!,,,:I -clear,:I -open,:v 0 :d 1 :ex ' start 2 ' :pr 2
:J,,,$,$ = float = state (0‚ 1‚ 2),general,0,toggle-float send domain,other --> more --> float send,no,When :J 0‚ toggle-float messages will only be received by a context open in the same patch. This means that two patches which share the same context ID numbers will not communicate with each other if they are both open at the same time. When :J 1‚ float send will communicate with any context open in any patch. When :J 2‚ float send will communicate only with Contexts embedded within this one. This is useful if for using Context as a sort of sample database.,Use this to safeguard against accidental interference between different conttext networks.,With :J 1 on‚ the context toggle-float will start another context number 2 in another patch‚ if such a context exists.,:J,,:v 0 :x 1 5 :i 2.5 0 0 0 1.5 :d 1 :s :pr 2
:K,,* / off ^ map none,$,$ = float (0‚ 1‚ 2‚ 3‚ 4) or symbol (see alias),time,0,set coefficient mode,timing --> calculation --> calculation mode,no,This sets how the coefficient (:k) value affects the cycle time. With :K 1 the :d value (top-left atom) is multiplied into the :k value. With :K 2‚ the atom is divided by the :k value (:k/:d). With :K 3‚ the :K value is taken to the :d-th power (:k^:d). With :K 4‚  custom map may be established (enter a list of numbers for :k) such that :d1 = :k1‚ :d2 = :k2‚ etc. With :K 0 (default) the :k value is ignored.,:K 1 allows you to create you own time units‚ ie. minutes (:k 60) instead of seconds. :K 2 means that the time atom (top left) determines inverse time values‚ ie. 2 for half a second‚ 3 for a third of a second‚ etc. (assuming that :k is set to 1). This is very useful for musical notation!,Here‚ :k is set to 2 and :d to 3. With :K 1‚ the cycle time will be 2 * 3 = 6 seconds. With :K 2 the time will be 2/3 of a second.,:K 1,:K 2,:v 0 :x 5 :i 5 1.5 :d 3 :s :k 2 :pr 2
:L,,all random linear,$,$ = float (0‚ 1‚ 2) or symbol (see alias),burst,0,select from three common burst settings,burst --> presets,no,This burst has a near infinite arrange of settings‚ but the three extremes which are most useful are ALL‚ RANDOM and LINEAR. ALL means that all open burst toggles will be fired at the end of every cycle. RANDOM means that a single random toggle will fire‚ with even distribution. LINEAR means that the toggles will fire one by one sequentially.,This is just a convenient way of navigating the otherwise dense set of burst controls.,The burst is set to ALL by default. You can choose RANDOM and LINEAR here to see the difference.,:L random,:L linear,:v 0 :y 1 2 3 4 :i 5 1.5 :d .7 :s :L all :pr 2
:M,,,$,$ = float = state (0‚ 1),general,0,switch x and y axes,no,shift and double click over the time atom (top left),Note that the toggle‚ toggle-float and database arrangements are all flipped‚ just as you would expect.,Since PD does not allow for outlets on the side of an object‚ the burst toggles can be difficult to access. The solution is to flip the axes‚ so that the burst is along the bottom.,,:M,,:v 0 :a ' x1 | x2 | x3 | x4 ' :b ' y1 | y2 | y3 | y4 ' :x 1 2 3 4 :y 1 2 3 4 :i 5 1.5 :d 2 :s :e 4 :f 4 :pr 2
:N,,hold,$,$ = float = value,input,n/a,queue the next context command,no,no,:N allows you to delay the effect of another context command. The float value determines how long you want to delay it. Each time any input is received‚ the command will move one place higher on the list. Without any further arguments‚ :N will hold the next command that the context receives. One context can have any number of queued commands. ,Delaying commands is especially useful for toggles. Cue a toggle to be switched in three bars time and then wait.,Press ‘:N 3’ followed by ‘stop’ and you will queue the stop message for three cycles. Make sure you press ‘stop’ before the end of the next cycle‚ otherwise you will queue the next ‘start’ message‚ not the stop!,:N 3,stop,:v 0 :x 5 :i 5 1.5 :d 2 :s :pr 2
:N,,hold,$’1 $’2...,$’1 = value‚ $’2 = context command letter,input,n/a,queue specified context command,no,no,:N allows you to delay the effect of another context command. The float value determines how long you want to delay it. Each time any input is received‚ the command will move one place higher on the list. One context can have any number of queued commands.,Delaying commands is especially useful for toggles. Cue a toggle to be switched in three bars time and then wait.,Everything after the :N x message will be delayed by x commands. A ‘command’ is any input that context receives‚ including automatic start messages. So the effect is that the message is delayed by x cycles. The :N 2 appears to be delayed by only one cycle‚ but this is because the subsequent message is compound of two commands‚ :d and :s‚ each of which counts as one. Note that setups like this work better with safety off (:z 0)‚ since otherwise the input will be closed for 10ms each cycle‚ preventig some of the desired messages from getting through.,:N 3 :x 3,:N 2 :d * -1 :s,:v 0 :x 1 4 5 :i 5 1.5 :rd 1 :d 2 :s :z 0 :pr 2
:N,,hold,$’1 $’2 {$’3...},$’1 = value‚ $’2 = symbol‚ $’3 = command,input,n/a,queue a context command with conditional return,no,no,Usually‚ held commands are pushed up the queue by any (recognized) context input. The second argument to :N locks the command to one input. So ‘:N 3 y’ means that the following command will only be advanced by the :y command‚ ie. the third :y command that is received will trigger the held command. Note that the second argument does not take a colon (‘x’ instead of ‘:x’).,Use this to define conditional changes to a context.,Once you press the :N message‚ it queues the :x command‚ which will only respond to the :y command. The result is that the :x toggle will be triggered on the third :y input.,:N 3 y :x 2,:y 1,:v 0 :x 5 :i 5 1.5 :d 2 :s :pr 2
:NN,,,$,$ = any,input,n/a,custom advance for conditional queue return,no,no,The :NN command is used with the :N command. It can be used to advance a queued message without triggering the a command in the process.,You can use this command to advance :N messages with arbitrary arguments‚ ie. ‘:N 2 foo :x 2’ and ‘:NN foo’.,Here‚ the queued message will only be advanced with a :y message. But you can forward it without triggering a y-axis toggle by using ‘:NN y’.,:N 3 y :x 2,:NN y,:v 0 :x 5 :i 5 1.5 :d 2 :s :pr 2
:O,,shuffle,$,$ = float = percentage (+ve or -ve),time,0,shuffle for pattern bank,timing --> more --> shuffle,no,This adds a shuffle to the timing of the pattern‚ affecting even numbered beats. Positive numbers push them forward‚ while negative numbers bring them back. Note that shuffling a Context with an odd number of toggles on the pattern axis will distort the cycle. For this reason‚ it’s best to stick to even numbered Contexts when using Shuffle.,Use this to enhance a rhythm stored in the pattern bank.,Look at the gaps between the beats when shuffle is on.,:O 60,:O -60,:v 0 :x 1 2 3 4 5 :i 5 1 :d 2 :s :pr 2
:P,,,$,$ = float = value,burst,0,define an arithmetic progression for the burst selection,burst --> selection --> progression,no,Note that if 10 toggles are selected‚ ':l 9'  is equivalent to a decreasing progression.,Use this to make a linear progression from one toggle to the next.,Look at which toggles are firing each cycle.,:P 1,:P 2,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :o 2 4 :d 1 :s :v 0 :pr 2
:Q,,,$,$ = float = state (0‚ 1),time,1,determine whether random timing auto-advances after every cycle,timing --> random options --> auto advance,no,This setting works in conjunction with random timing (:E 1). When on (default)‚ a new cycle time is randomly selected after each cycle. When off‚ context waits to receive a ‘bump d’ message to advance the timing.,Use this if you want to hold random timings for more than one cycle.,With :Q off‚ new cycle timings will not be selected‚ until context receives a ‘bang d’.,:Q,bump d,:v 0 :x 5 :i 5 1.5 :d 3 :q 1 :E 1 :s :pr 2
:R,,,$,$ = float = percentage,burst,0,randomize the burst toggle selection,burst --> selection --> random,no,This setting works as a percentage. 0 means that the toggle selection is definitive and 100 means that it is totally random. Number in between describe varying degrees on uncertainty‚ so that the next toggle will deviate from the last one with :l likelihood‚ according to Gaussian distribution. Note that this works for any number of toggles‚ with the toggles’ previous positions being the center point. 101 gives even distribution through an ‘urn’ generator. This means that all available numbers will be used once before the urn is reset‚ like pulling numbers out of a bag. The urn can be reset manually using the ‘bump R’ command.,Use this setting to add uncertainty in a context network.,,:R 100,:R 2,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1 :d .7 :s :o 1 3 5 :v 0 :pr 2
:R,-open,,,,burst,n/a,edit random distribution array,burst --> selection --> edit random,no,This command opens the array which defines the probabilities for the :l setting. Normally you will see a Bell curve here (if :l is greater that 0 and less than 100)‚ but you can draw in a curve to define a new range of probabilities. Unfortunately‚ any changes you make here are unsavable.,Use this to define custom probabilities for the burst selection.,Open the array and draw in your own curve. You will see the changes reflected in the selection of burst toggles that fire.,:R -open,:R 20,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 2 :s :v 0 :pr 2 :R 30
:S,,,$,$ = any,database,blank,prepend custom text to the x-axis database,message --> x-axis --> prepend,no,This prepends any custom text to the beginning of every message sent from the bank database.,This can help to simplify and organize database storage. It is also useful if you want to is the [ or [o message variables to direct the context outlet.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :S.,:S carrot,:S tomato,:X 9 :d 4 :v 0 :a ' 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 ' :e 8 :x 1 2 3 4 5 6 7 8 9 :i 9 1.5 :s :pr 2
:T,,,$,$ = any,database,blank,append custom text to the x-axis database,message --> x-axis --> append,no,This append any custom text to the end of every message sent from the bank database.,This can help to simplify and organize database storage.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :T.,:T brocolli,:T cabbage,:X 9 :d 4 :v 0 :a ' 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 ' :e 8 :x 1 2 3 4 5 6 7 8 9 :i 9 1.5 :s :pr 2
:U,,,$,$ = any,database,blank,prepend custom text to the y-axis database,message --> y-axis --> prepend,no,This prepends any custom text to the beginning of every message sent from the bank database.,This can help to simplify and organize database storage. It is also useful if you want to is the [ or [o message variables to direct the context outlet.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :S.,:U carrot,:U tomato,:d 3 :v 0 :b ' 1 | 2 | 3 | 4 ' :f 4 :y 1 2 3 4 :i 5 1.5 :M 1 :s :pr 2
:V,,,$,$ = any,database,blank,append custom text to the y-axis database,message --> y-axis --> append,no,This append any custom text to the end of every message sent from the bank database.,This can help to simplify and organize database storage.,Look at the text that appears in the symbol atom vs. the text that prints in the console to undestand the effect of :T.,:V brocolli,:V cabbage,:d 3 :v 0 :b ' 1 | 2 | 3 | 4 ' :f 4 :y 1 2 3 4 :i 5 1.5 :M 1 :s :pr 2
:W,,,$,$ = float = state (0‚ 1),burst,0,determine whether random burst selections can wrap,burst --> selection --> wrap,no,,When there is a small amount of random deviation to the number of burst toggles (ie. :R 10)‚ the number will follow a ‘drunken walk’ pattern. The :W setting determines whether it hits a ‘wall’ at the end or whether it wraps back around‚ ie. If the toggles can randomly go from the top to the bottom of the toggle array.,With :W off you will probably see the selected toggle hitting a wall an staying there‚ whereas with :W on it will wrap around to the other edge.,:W 1,:W 0,:Y 6 :y 1 2 3 4 5 6 :i 5 1.5 :R 10 :d .1 :s :v 0 :pr 2
:X,,,$,$ = float = number of toggles,general,5,set x-axis length,no,shift + click and drag over the right-hand margin,This causes audio drop-outs.,Dragging the GUI is much more accessible‚ but this command may be useful for resizing large groups of contexts.,,:X 2,:X 9,:v 0
:Y,,,$,$ = float = number of toggles,general,4,set y-axis height,no,shift + click and drag over the bottom margin,This causes audio drop-outs.,Dragging the GUI is much more accessible‚ but this command may be useful for resizing large groups of contexts.,,:Y 1,:Y 7,:v 0
:Z,,,$,$ = float = value,general,7,set the size of the input atoms,no,shift + click and drag over the atom’s right edge,:Z 0 hides the atoms completely.,This is for convenience and has no other effect.,,:Z 32,:Z 0,:: long :v 0
:ba,,,list,semi-colon separated,input,blank,store the bank settings,other --> bank --> edit,no,Note that you can’t type semi-colons within PD‚ so these lists are difficult to edit.,Bank list saving generally takes care of itself and so this command is best left untouched.,No example given.,,,:v 0
:es,,,$,$ = float = state (0‚ 1),overlay,0,determine whether embedded contexts come to a hard stop,other --> more --> overlay --> embed stop,no,When one context is embedded inside another (ie. created in the overlay)‚ it will turn and stay on while the parent context’s cursor hovers over it. This setting determines how the context stops. :es 0 brings the embedded context to a hard stop when the cursor passes‚ whereas :es 1 lets it come to the end of its cycle.,Use this to determine the behaviour of embeded contexts,No example given.,,,:v 0
:ex,,,list,semi-colon separated,input,blank,store the exception list,other --> exceptions --> edit,no,Note that you can’t type semi-colons within PD‚ so these lists are difficult to edit.,Exception list saving generally takes care of itself and so this command is best left untouched.,No example given.,,,:v 0
:id,,:ID,$,$ = float = value,ID,blank,assign an ID number to context,ID --> ID number,no,Each context has one unique ID number which is used for sending and receiving messages. If the ID number is 6‚ context will receive messages through the ‘c6’ and send them to the ‘c6-’ channel.,ID numbers generally take care of themselves and are best left untampered with‚ but can be manually controled using the :ID command.,Look for the ID number on the context canvas.,:id 2,:id 4,:v 0
:il,,,$,$ = float = state (0‚ 1),general,0,display brief label on valid input command,other --> state --> input label,no,This turns on a function which recognizes every new command that the Context receives with a small label at the top of the GUI.,The label is useful for understanding Context commands.,When labeling is turned on‚ all changes to the Context state (ie. opening and closing toggles) will be briefly displayed above the Context GUI.,:il 1,:il 0,:v 0 :il 1
:io,,,$,,overlay,blank,overlay inlets~ and outlets~,,create objects on the overlay ???,,,,,,:v 0
:ol,,,$,$ = float = state (0‚ 1),overlay,0,optimize context for embedding,other --> more --> overlay -->embedded,no,Context’s behaviour changes slightly when an object is enbedded in it: 1. It’s DSP is switched on (for embedded contexts). 2. The overlay patch is saved in the creation argument. 3. Context resizing (:X and :Y) changes slightly to account for embedded objects. This setting generally takes care of itself and it is best to leave it untouched. However‚ you can use this to switch back to regular mode. (Context resizing is more clunky with :ol 1‚ which is one reason you might want to switch back).,Turn :ol off if you have embeded objects in the overlay patch but outside of the GOP area to improve context resizing.,No example given.,,,:v 0
:ol,-save,,,,overlay,n/a,save exception overlay,other --> more --> overlay --> save overlay,no,This saves the overlay patch to context’s creation argument‚ but you need to save the main patch again (ctrl+s) to save it to file.,,,:oI -save,:oI -open,:v 0
:ol,-open,,,,overlay,n/a,open a text dialogue to manually edit the exception list,other --> more --> overlay --> view overlay,right click + open,,,,:oI -save,:oI -open,:v 0
:ol,-clear,,,,overlay,n/a,clear the exception list,other --> more --> overlay --> clear overlay,no,This clears the overlay from the creation argument‚ but does not affect the overlay patch. Re-saving the patch will undo the clear.,,No example given.,,,:v 0
:pr,,print,$,$ = float = state (0‚ 1‚ 2),general,0,print context output and state,other --> state --> auto print,no,1 prints all output messages to the console as they are sequenced. 2 prints this as well as any command input.,This is useful for designing and debubbing.,,:pr 1,:pr 2,:v 0 :x 5 :i 5 1.5 :d 1 :s
:pr,,print,{$’1},$ = command letter (or ‘overlay‘),saving,n/a,print context settings to the console,other --> state --> print state,no,This prints the context’s current state to the console. The first term of the printed message is the context’s ID number.,Use this to examine or copy a context’s state. A simple ‘print’ message with no argument will fetch the entire state‚ while individual command characters (without the colon) will fetch specific states (ie. ‘print d a’ to see the :d and :a settings). ‘print -overlay’ prints the entire context state plus the overlay patch. ,,print overlay,print d a,:v 0 :d 3 :a this is my message :pr 2
:rd,,,$,$ = float = state (0‚ 1),operation,0,switch first and last toggle for reverse playback,other --> more --> cycle reversal → reverse last,no,This setting addresses a specific problem. The last toggle is often used to loop a context‚ as in the example‚ but the logic of this is broken if the context cycle is reversed (ie. if :d is negative). :rd reverses the order of the first and last toggle so that loops can remain intact. The reversal only comes into effect when the cycle is negative.,Use this if you want to be able to reverse a context that is auto-looped.,‘ :d * -1 :s ‘ reverses the context cycle and ‘ :rd ‘ turns this setting on and off. Explore the four different combinations and you will see that the loop fails if the cycle is reversed and :rd is off.,:d * -1 :s,:rd,:v 0 :x 1 2 4 5 :i 5 1.5 :d 2 :rd 1 :s :pr 2
:rt,,,$,$ = float = state (0‚ 1),operation,0,shift toggle alignment in reverse playback.,other --> more --> cycle reversal → offset pattern,no,This setting addresses a specific problem. When Context has its cycle time reversed‚ the Pattern will usually play back in reverse‚ with the last toggle going at the very beginning and the first toggle going at the very end. This makes sense logically‚ but not musically. If we want to play a pattern ‘A B C D’ in reverse‚ we want the ‘A’ to come ¾ of the way through the bar‚ not at the end of it. The :rt setting corrects this problem by shifting the alignment of the internal counter with the toggle array‚ so that in reverse‚ the last beat of the bar (the second last toggle) comes first‚ the second-last beat of the bar comes second‚ etc. A side effect of this is that there is no toggle toggle left to play at the very end of the cyce—unless you are using :rt in conjunction with :rd.,Use :rt if you want to play a melody in reverse‚ with the (old) first beat of the bar playing on the (new) last beat. Use in conjunction with :rd if you want the Context to be able to repeat‚ ie. bounce back on itself.,Notice how the Context pattern is playing (ie. watch the printing messages). With :rt on‚ the pattern is ‘A-B-C-D-D-B-C-A-...’. With :rt off‚ it is ‘A-B-C-D-BLANK-D-C-B-...’.,:rt 1,:rt 0,:v 0 :d 2 :rt 1 :rd 1 :b ' | | | . :d * -1 :s ' :pr 1 :a a | b | c | d :x 1 2 3 4 5 :e 5 :s
:rm,,,$,$ = float = state (0‚ 1),messages,1,determine whether random variable (?) auto-advances after every cycle,messages --> variables --> ? auto advance,no,This setting determines whether the ? message variable selects a new random value every time it fires.,Note that you can advance the ? variable at any time using the ‘bump m’ message.,The database contains the text ‘? 10’‚ so Context will send a random number between 0 and 9 each time it fires. If :rm is off‚ the random number will persist until :rm is switched on again‚ or it receives a “bump m” message.,:rm,bump m,:v 0 :a ‘ ?10 ‘ :x 1 2 3 4 5 :i 5 1.5 :d 2
:ro,,,$,$ = float = value,messages,0,create an offset for the ? variable,messages --> variables --> ? offset,no,This adds a single digit to the random values which are selected by the ? variable.,The basic purpose of this setting is to ensure that there are no zeros in random arrays‚ so that they can generate meaningful data for setting toggles. Beyond this‚ it is also possible to add decimal places‚ or random numbers which might be below 0.,,:ro 1,:ro 10,:v 0 :a ‘ ?10 ‘ :x 1 2 3 4 5 :i 5 1.5 :d 2 :pr 2
:nr,,,$,$ = float = state (0‚ 1),messages,0,determine whethther the ID variable (^) selects randomly or sequentially,messages --> variables --> ^ random,no,The ^ message variable returns an ID number in place of a tag (argument). This setting determines whether the ID number is chosen randomly or sequentially.,Use this when using one Context to control a group of other Contexts.,No example given.,,,:v 0
:se,,,$,$ = float = state (0‚ 1‚ 2),general,0,determine where the context menu commands are sent,other --> send settings to,no,This command makes the context menu affect more than one context. :se 1 allows you to send settings to all contexts‚ effectively turning the selected one into a global menu. :se 2 sends the setting selections only to the context’s outlets. The default :se 0 means that only the given context will be affected by the menu selection. Creating a global menu can get confusing‚ but it is always possible to bypass the :se setting by pressing Ctrl.,,No example given.,,,:v 0
:se,,,$,$ = symbol,general,blank,send the context menu commands to  custom channel,other --> send settings to,no,This selects a custom send channel for the context’s menu selection. Ie. ‘ :se guitar ‘ will send the settings to any contexts with the tag ‘guitar’.,,No example given.,,,:v 0
:te,,tempo,$,$ = float = value,time,100,mutliply the cycle time,timing --> calculation --> tempo,no,This multiplies the cycle time by a given percenage to allow for global tempo changes.,The :te setting is no different than the :K 1 setting—it is simply a multiplier for the cycle time. Why does it exist? So that you can change the tempo of a group of Contexts even while some of them still have independent :k values.,The :te value would only stand out as useful if you wanted to change the global tempo of a set of Contexts‚ some of which were using :k and :K for other purposes.,:te 75,:te 115,:v 0 :x 1 2 3 4 5 :i 5 1.5 :d 2 :s :pr 2 :s
:x1,:x2 :y1 :y2,,$,$ = float = seconds,overlay,0,determine context’s position on a parent canvas,no,use [move] abstraction,:x1 = x start point‚ :x2 = x end point‚ :y1 = y start point‚ :y2 = y end point.,These commands only come into effect when context is embedded in a timeline. They generally take care of themselves and are best left alone.,No example given.,,,:v 0
:ln,{-},,$,$ = symbol,operation,blank,set a custom receive channel,ID --> receive,no,This creates a custom recieve channel which can be used to send messages to Context. This can also be done with tags (:n)‚ but :ln has a few differences. 1: Only one :ln channel can exist‚ and it has no send component. 2: It can be set dynamically without creating audio dropouts. 3: n optional ‘-’ argument at the beginning means that Context will start every time it receives input through that channel.,Use this to link two Contexts together‚ so that the output of one is automatically received by the other without having to connect them. If using ID numbers‚ make sure not to forget the dash (ie. ‘c2-’).,This example won’t demonstrate very much unless you create another Context with ID number 2.,:ln c2-,:ln – c2-,:v :d 1
bump,,,,,burst,n/a,advance the burst selection,no,no,This selects a new set of burst toggles‚ according to the burst settigs.,Use this in conjunction with burst auto-advance (:m 0).,While :m 0 is set‚ the toggle selection won’t advance unless the context receives a ‘bump’ message. When :m 1 is set‚ toggle selection advances each burst cycle.,bump,:m,:Y 8 :y 1 2 3 4 5 6 7 8 :i 5 1.5 :d .7 :h 1 :m 0 :P 1 :s :v 0 :pr 2
bump,d,,,,time,n/a,advance the random timing,no,no,This selects a new random cycle time.,Use this in conjunction with random timing (:E 1) and random advance (:ra 0).,:E 1 is on‚ but with :ra off‚ new cycle timings will not be selected until context receives a ‘bang d’.,:ra,bump d,:v 0 :x 5 :i 5 1.5 :d 3 :q 1 :E 1 :ra 0 :s :pr 2
bump,m,,,,general,n/a,advance the random message variable (?),no,no,This advances the random message variable for output messages.,Use this to select a new random value if :rm is off.,The database contains the text ‘? 10’‚ so Context will send a random number between 0 and 9 each time it fires. If :rm is off‚ the random number will persist until :rm is switched on again‚ or it receives a “bump m” message.,:rm,bump m,:v 0 :a ‘ ?10 ‘ :x 1 2 3 4 5 :i 5 1.5 :d 2
bump,l,,,,burst,n/a,reset the burst quantity urn,no,no,If :l is set to 101‚ the burst quantity will be determined by an urn (that is‚ each number will be selected once at random‚ like taking numbers out of a bag‚ before being reset). “bump l” resets the urn‚ putting all the numbers back in the bag.,:l 101 is useful if you want every open toggle to be randomly selected once in a sequence. Use “bump l” to establish the beginning of the sequence.,Look at how many toggles fire each cycle to understand lR 101. The sequence will come in groups of 4. “bump l” will define the beginning of the group.,bump l,,:M 1 :x 1 2 3 4 5 :i 5 1.5 :d 1 start :v 0 :l 101
bump,R,,,,burst,n/a,reset the burst selection urn,no,no,If :R is set to 101‚ the burst quantity will be determined by an urn (that is‚ each number will be selected once at random‚ like taking numbers out of a bag‚ before being reset). “bump R” resets the urn‚ putting all the numbers back in the bag.,:R 101 is useful if you want every open toggle to be randomly selected once in a sequence. Use “bump R” to establish the beginning of the sequence.,Look at which toggles fire each cycle to understand :R 101. The sequence will come in groups of 4. “bump R” will define the beginning of the group.,bump R,,:M 1 :x 1 2 3 4 5 :i 5 1.5 :d 1 start :v 0 :R 101
fetch,,,$’1 $’2,$’1 = symbol = channel‚ $’2 = symbol = command letter,general,n/a,fetch a context setting and send it to a specified location,no,no,Like print‚ ‘fetch’ helps you retrieve something from the context state save list‚ but instead of printing it sends it to a specified location (the first argument). Note that the first argument is any context command but without the colon.,Use ‘fetch’ to retrieve and process a part of a context’s state (ie. a toggle selection).,You would need to create the object [receive new-channel] in order to view the retrieved data.,fetch d,fetch x,:v 0 :x 1 3 4 :d 3 :pr 2
find,,,$ $...,$ = float = ID number or symbol = tag,general,n/a,locate context ID numbers and toggles on the canvas,no,no,This helps you locate lost numbers on a larger canvas. ID numbers‚ toggle floats and tags are all searched. Very handy!,Note that this command is much more useful when it is sent to all contexts ( [s context] ) rather than one individual context‚ as in the example.,,find 1 6,find my-tag,:v :x 1 2 3 4 5 :y 1 2 3 :i 1.5 2.5 3.5 4.5 5.5 :j 6.5 7.5 8.5 :n my-tag :pr 2
rev,,,$,$ = float = state (0‚ 1),time,0,reverse the Context cycle,no,negative float-atom value,1 reverses the Context cycle‚ ensuring that the burst fires before tthe pattern and the pattern cycles in reverse. 0 puts it back to its normal cycle. No argument (just ‘rev’ or ‘rev bang’) toggles reverse‚ depending on the current state.,Use this to reverse the Context cycle. Note that it is functionally equivalent to selecting a negative :d value.,Note that :rd is on here to allow the loop to continue in reverse.,rev,rev 1,:v 0 :x 5 :i 5 1.5 :d 1 :pr 2 :rd 1 start :z 0
reset,-all,,,,saving,n/a,reset the context state to default,no,no,This resets the context to the familiar green‚ 5x4 default. The ID number remains.,It’s ‘reset’ that is being used in this patch to reset the example context each time a new command box is selected.,,reset -all,,:v 0 :X 6 :Y 5 :c 19 :d 4 :a message :pr 2
reset,,,$ $,$ = symbol = command letter,saving,n/a,reset the specified settings,no,no,This resets only the settings specified. Note that the arguments are command letters without the colon (ie. ‘g’ instead of ‘:g’).,,,reset X d,reset c x,:v 0 :X 7 :c 2 :d 3 :x 1 2 3 4 :pr 2
savelist,,,,,saving,n/a,open a text dialogue to manually edit the entire context state,other --> state --> edit list,no,This opens a text dialogue box with the entire context state‚ for viewing and editing.,,,savelist,,:v 0
stop,,,,,operation,n/a,stop the context cycle,no,click and hold on the coloured context canvas area,This stops context immediately.,,,start,stop,:v 0 :x 5 :i 5 1.5 :d 1 :s :pr 2
stop,,,$ $...,$ = symbol = ID (tag or number),operation,n/a,stop a set of contexts,no,no,This should work in combination with any other ‘stop’ command. Note that the ‘context’ tag is useful here for stopping all contexts.,Use this to stop any group of contexts‚ according to ID number or tag.,This will stop all contexts currently cycling‚ not just the example one.,start,stop context,:v 0 :x 5 :i 5 1.5 :d 1 :s :pr 2
stop,*,,,,operation,n/a,stop a context at the end of its cycle,no,no,This waits until the context cycle is finished and then stops it. It should work in combination with any other ‘stop’ command.,Use this to bring a context network to a soft stop rather than a hard.,Press the ‘stop *’ message before the end of the cycle and watch it finish.,start,stop *,:v 0 :x 5 :i 5 1.5 :d 1 :s :pr 2
stop,-,,$ $...,$ = symbol = ID (tag or number),operation,n/a,stop contexts with exceptions,no,no,This stops a context unless one of its arguments matches the context ID. It should work in combination with any other ‘stop’ command.,This command is very useful for creating a ‘solo’.,'stop – 1’ won’t stop the context because ID 1 is treated as an exception. This command is much more useful when you are sending the ‘stop’ message to a group of contexts through tag receive channels. For instance‚ ‘stop – drums’ being sent to [send context] would stop all contexts other than those tagged with ‘drums’. This is very useful for creating ‘solos’.,stop - 2,stop - 1,:v 0 :x 5 :i 5 1.5 :d 1 :pr 2
marker,,,$`1  ` $`2... `,$`1 = float = marker ID‚ $`2... = any marker message,overlay,n/a,send message to embedded marker,no,no,Use this to send commands to any Marker embedded inside Context. The first argument is the Marker ID number. Next follows any Marker command.,Remember to use quotation marks around the Marker command.,No example given—see ‘marker-help.pd’.,,,:v 0
content,,,$`1  ` $`2... `,$`1 = symbol  = content ID‚ $`2... = any content message,operation,n/a,send message to embedded content,no,no,Use this to send commands to any Content embedded inside Context. The first argument is the Cotent name. Next follows any Content command.,Remember to use quotation marks around the Content command.,No example given—see ‘content-help.pd’.,,,:v 0
